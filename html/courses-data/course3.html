<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Курс третий</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <h1>Курс 3. Построение сеток</h1>
    <table>
            <tr>
                <td class="tablehead"><b>Оглавление:</b></td>
                </tr>
            <tr>
                <td><a href="#ch00">Блочные и строчные элементы</a></td>
                </tr>
            <tr>
                <td><a href="#ch10">Отступы</a></td>
                </tr>
            <tr>
                <td><a href="#ch20">Блочная модель и строчные элементы</a></td>
                </tr>
            <tr>
                <td><a href="#ch30">Управление типом элемента, свойство display</a></td>
                </tr>
            <tr>
                <td><a href="#ch40">Сетки</a></td>
                </tr>
            <tr>
                <td><a href="#ch50">float и выпадание из потока</a></td>
                </tr>
            </table>
    <h2 id="ch00">Блочные элементы</h2>
    <p>К блочным элементам относятся такие теги как: <a>&lt;p>, &lt;h1>, &lt;h2>, &lt;ul></a> и так далее. Еще один важный блочный тег — это тег <a>&lt;div></a>, который обозначает просто «блок» или «прямоугольный контейнер». Этот тег чаще всего используется для создания сеток. До и после блочного элемента существует перенос строки. Блочным элементам можно задавать ширину, высоту, внутренние и внешние отступы. Занимают всё доступное пространство по горизонтали.</p>
    <h2>Строчные элементы</h2>
    <p>Строчные элементы располагаются друг за другом в одной строке, при необходимости строка переносится.</p>
    <div>
        <p class="a">Особенности строчных элементов:</p>
    <ol>
        <li>До и после строчного элемента отсутствуют переносы строки.</li>
        <li>Ширина и высота строчного элемента зависит только от его содержания, задать размеры 
            с помощью CSS нельзя.</li>
        <li>Можно задавать только горизонтальные отступы.</li>
    </ol>
    </div>
    <p>К строчным элементам относятся такие теги как: <a>&lt;a>, &lt;strong>, &lt;em>, &lt;span></a> и так далее. Строчные элементы предназначены для оформления текста на уровне небольших фраз и отдельных слов. Блочные же элементы предназначены для разметки крупных блоков текста (заголовки, абзацы, списки) и создания сетки.</p>
    <p>Строчные элементы не создают переносов строки до и после себя. Такие элементы располагаются в строке слева направо. Если строчный элемент не помещается в родительский контейнер, то он переносится на следующую строку. Ширина и высота элементов задаются с помощью свойств width и height соответственно. Строчные элементы не реагируют на задание ширины и высоты в CSS. </p>
    <h2 id="ch10">Отступы</h2>
    <p>Вертикальный отступ между двумя соседними элементами равен максимальному отступу между ними. Если отступ одного элемента равен 20px, а второго 40px, то отступ между ними будет 40px. Этот эффект называется эффектом «схлопывания» внешних отступов или «схлопывания» маргинов.</p>
    <p><a>«Выпадание» внешних отступов.</a><br> «Выпадание» — это еще один эффект, связанный с вертикальными внешними отступами. Если внутри родительского блока расположить блок и задать ему отступ сверху, то внутренний блок прижмется к верхнему краю родительского, а у родительского элемента появится отступ сверху. То есть верхний отступ внутреннего элемента «выпадает» из родительского элемента. Если у родительского элемента тоже был задан внешний отступ, то выберется максимальный отступ между собственным и «выпавшим». Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу внутренний отступ (паддинг) сверху или добавить рамку сверху. Внешние и внутренние отступы всегда складываются.</p>
    <div>
            <p class="a">Чтобы отцентровать блочный элемент, нужно выполнить следующие действия:</p>
        <ol>
            <li>Задать элементу ширину, которая меньше ширины родительского контейнера.</li>
            <li>Задать для внешних отступов справа и слева значение auto.</li>
        </ol>
        </div>
    <h2 id="ch20">Блочная модель и строчные элементы</h2>
    <div>
            <p class="a">Еще раз акцентируем внимание на особенности поведения строчных элементов в блочной модели:</p>
        <ol>
            <li>Не реагируют на CSS-свойства width и height.</li>
            <li>Частично реагируют на margin, воспринимая только горизонтальные отступы.</li>
            <li>Частично реагируют на padding, воспринимая только горизонтальные отступы.</li>
            <li>При задании вертикальных padding визуально увеличиваются, но без увеличения занимаемого места (не отталкивают другие элементы).</li>
            <li>Воспринимают рамки. Аналогично padding рамки сверху и снизу не увеличивают занимаемое элементом место.</li>
        </ol>
        </div>
    <p>CSS-свойство width задаёт не общую ширину блока, а только ширину содержания. Общая ширина блока затем складывается из трёх компонентов: ширины содержания, внутренних отступов и ширины рамок слева и справа.<br>В чём проблема описанного механизма расчета ширины?. Ведь можно просто не задавать ширину, используя auto, либо просто подбирать размеры блоков и отступов как на макете.<br>Проблемы начинаются, когда сетка резиновая и элементы в ней должны тянуться. Самый простой пример: форма, в которой поля должны занимать всю ширину контейнера, но при этом иметь фиксированные внутренние отступы, чтобы текст не прилипал к краям.<br>Для такой формы можно задать такие стили:</p>
        <p class="st10">input[type="text"] {<br>
        width: 100%;<br>
        padding: 0 10px;<br>
        box-sizing: border-box; - для растягивания полей формы<br>
        }<br>
    </p>
    <h2 id="ch30">Управление типом элемента, свойство display</h2>
    <p>Тип элемента не является чем-то вечным и неизменным, его можно изменять с помощью CSS. За это отвечает свойство display. С его помощью, например, можно сделать абзацы и заголовки строчными, а спаны и стронги блочными элементами. У свойства display много значений. С двумя из них вы уже заочно познакомились. Свойство  display: block обозначает блочный элемент, а display: inline — строчный.</p>
    <p><a>Блочно-строчные элементы.</a> В HTML нет тегов, которые по умолчанию вели бы себя как блочно-строчные, но любой элемент можно переключить в данный режим, задав ему свойство display со значением inline-block.</p>
    <div>
            <p class="a">Особенности блочно-строчных элементов:</p>
        <ul>
            <li>им можно задавать размеры, рамки и отступы, как и блочным элементам;</li>
            <li>их ширина по умолчанию зависит от содержания, а не растягивается на всю ширину контейнера;</li>
            <li>они не порождают принудительных переносов строк, поэтому могут располагаться на одной строке, пока помещаются в родительский контейнер;</li>
            <li>элементы в одной строке выравниваются вертикально подобно строчным элементам.</li>
        </ul>
        </div>
    <h2 id="ch40">Сетки</h2>
    <p>Поток — это порядок отображения элементов на странице. По умолчанию блочные элементы отображаются как прямоугольные области, идущие друг за другом сверху вниз, а строчные элементы располагаются сверху вниз и слева направо и при необходимости переносятся на новую строку. Потоком можно управлять и изменять привычное поведение элементов в потоке. Например, можно заставить блочные элементы двигаться не сверху вниз, а выстраиваться в несколько колонок.</p>
    <p>float: right, left - положение блока на странице</p>
    <p>clear: both - позволяет избавится от эффекта наползания</p>
    <div>
        <p class="a">Существует несколько способов управлять потоком и строить сетки:</p>
    <ol>
        <li>флоаты;</li>
        <li>инлайн-блоки;</li>
        <li>табличная вёрстка;</li>
        <li>флексбоксы.</li>
    </ol>
    </div>
    <p>Табличная вёрстка — самый простой для понимания способ построения сеток. Но он считается устаревшим и использовать его не рекомендуется. Сейчас уже можно использовать для такой вёрстки не таблицы, а элементы с display: table, display: table-row и display: table-cell. Подробно эта тема рассматриваются в курсе «Таблицы на CSS». Флексбоксы — это новая и очень мощная технология для построения сеток. Подробно она разбирается в курсах Флексбокс, часть 1 и Флексбокс, часть 2. В этом курсе мы подробно разберём флоаты и инлайн-блоки. Основной упор сделаем на флоаты, так как сейчас на многих сайтах сетки построены на них.</p>
    <p>Есть тонкость, связанная со строчными элементами. Если зафлоатить строчный элемент, то он начинает вести себя как блочный, а именно: воспринимать размеры и отступы.</p>
    <h2 id="ch50">float и выпадание из потока</h2>
    <div>
        <p class="a">Зафлоаченные элементы выпадают из потока, но лишь частично:</p>
    <ul>
        <li>Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.</li>
        <li>Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.</li>
    </ul>
    </div>
    <p>Для блочных элементов флоатные не существуют, но текст внутри блоков флоатные обтекает.</p>
    <div>
        <p class="a">Такое поведение флоатов даёт интересные эффекты:</p>
    <ol>
        <li>Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.</li>
        <li>Эффект выпадания из родителя или схлопывания родителя. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены. В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого, а блоки выпадают из него.</li>
    </ol>
    </div>
    <p>Флоатные элементы становятся невидимыми для блочных элементов и видимыми для текста. А как же они взаимодействуют друг с другом?Если вкратце то: флоатные элементы видят друг друга.Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места. Если места не хватает, то они начинают переноситься на следующую строчку. Почти как текст. Как раз эта особенность флоатов и позволила применять их для создания сеток. Ведь в начале двухтысячных в CSS не было никакого другого способа создавать колонки и задавать им размеры. Блочные элементы всегда располагались в разных строках. А строчные элементы, хоть и могли располагаться на одной строке, совершенно не воспринимали размеры. Позиционирование тоже не подходило для сеток, так как элементы выпадали из потока. В общем, флоаты оказались как нельзя кстати для тех, кто решил уходить с табличной вёрстки.</p>
    <div>
        <p class="a">Свойство clear запрещает обтекание элемента другими элементами. Вот его значения:</p>
    <ol>
        <li>left — запрещено обтекание слева;</li>
        <li>right — запрещено обтекание справа;</li>
        <li>both — запрещено обтекание с обеих сторон;</li>
        <li>none — обтекание разрешено.</li>
    </ol>
    </div>
    <p>Эффект выпадания флоатов из родителя был большой проблемой при построении сеток. </p>
    <div>
        <p class="a">Ведь сетки на флоатах обычно делаются вот так:</p>
    <ol>
        <li>Создаём блок-контейнер для колонок.</li>
        <li>В контейнер добавляем флоатные блоки-колонки.</li>
        <li>Рассчитываем ширины колонок так, чтобы им хватало места в родителе.</li>
    </ol>
    </div> 
    <p>Такой подход работает неплохо. Но проблемы начинаются тогда, когда у контейнера есть фон, отличный от фона страницы. Когда колонки выпадали, родитель схлопывался и фон пропадал. Необходимо было найти способ борьбы с выпаданием. Тут и пригодилось свойство clear:both.</p>
    <div class="b">
    <p class="a">Стали применять такую структуру:</p>
    <p>&lt;div class="container"> - блок-контейнер<br>
        &lt;div class="column1">...&lt;/div> - колонка, флоат<br>
        &lt;div class="column2">...&lt;/div> - колонка, флоат<br>
        &lt;div class="clearfix">&lt;/div> - распорка с clear:both<br>
        &lt;/div>
    </p>
    </div>
    <p>Хорошие верстальщики не очень любят, когда в вёрстке появляются ненужные дополнительные элементы и стараются от них избавляться.
    До поры до времени с блоками-распорками приходилось мириться, так как без них было никак не обойтись. Но время шло и в браузерах появилась поддержка так называемых псевдоэлементов.
    Псевдоэлементы позволяют с помощью CSS вставить в структуру HTML-документа узлы, которых нет в HTML коде. То есть можно вставить в код элемент и не писать его в HTML. Благодаря псевдоэлементам появилось решение проблемы флоатов без использования дополнительного элемента.
    Назовём это решение псевдораспорками. Есть несколько его вариаций, но вот одна из распространённых.</p>
    <div class="b">
            <p class="a">В CSS добавляется следующее правило:</p>
            <p>.clearfix::after {<br>
                content: "";<br>
                display: table;<br>
                clear: both;<br>
            </p>
    </div>
</body>
</html>
